# Instructions

## Description

The project contained here is based on the VisualInterface project provided by Tom Clarke, with some modifications made to accommodate the nature of our code and implement important features to facilitate testing. Importantly, this does not test the whole pipeline of our project, but rather tests the functionality of the Execution part of the project (specifically, it tests the `InstructionsInterfaces` Module). Essentially, to have automated random testing, I have created a basic parser to convert a string containing an ARM instruction to the appropriate instruction in our project and compare the resulting output to the output generated by VisUAL. I have then assembled a random instruction generator, which concatenates different componenets together to generate an ARM instruction (as a string) and test it using the previously described method. Here, I will define the new functions to the project. Random testing is only applied to ALU Instructions. Memory instructions are tested manually.
Memory instructions are slighly more complicated that the ALU ones. Since I was not able to access the memory output from VisUAL, I was able to test load instructions, but not store instructions. As a result, I tested store instructions by storing some registers (with non-zero values in them) in memory and then loaded them. I did this both in VisUAL and in my implementation of the function to check correctness. The first 24 tests test LDRx4, STRx4, LDMx4, STMx4, LDRBx4, STRBx4.
It is important to note that when there is a mismatch between the output from VisUAL and my implementation, the project throws an exception. This will happen in this project because of a bug in VisUAL which sets the carry flag in some logical operations when it is not supposed to. The output of my implementation has been manually checked for correctness in such instances. Therefore, when this happens, simply ignore this and continue the project.
All tests use the Expecto framework.

---
## Types
* No types defined here
---
## Functions

* `makeRandomInstruction: unit -> string`: generates a random, valid ARM ALU instruction as a string
    * `getRandomInst: (unit -> (string*int)[] -> string*int)`: Picks a random instruction from the available instructions in `instructionARR`
    * `getRandomOp: unit -> string[] -> string`: picks a random operand from one of the `string[]` passed to it
* `stringFlag: FlagID -> MachineState -> string`: converts state of a flag to a string
* `stringConcat: MachineState -> string`: applies `stringFlag` to each flag and concatenates the result
* `parser: string -> MachineState -> MachineState`: simple parser to breakdown a string representing a valid ARM instruction and converting it to a function in my implemntation
    * `regMatcher: string -> RegisterID`: converts a string representing a register to `RegisterID` representation of a register
    * `registerOrLit: string -> Input`: Matches string representing an operand to `Input` representation of the operand
    * `instructionMatcher: string list -> MachineState`: matches a list of strings containing the building blocks of an instruction to my implementation of the instructions, while assigning all appropriate elements correctly
* `randFunc: string -> int -> Test`: generates a test based on initial condition codes represented in the `string` input

---
## Dependencies

* Common.fs
* Instructions.fs
* MemoryInstructions.fs
* InstructionsInterfaces.fs
* MachineState.fs
* Optics.fs
* Memory.fs

## Notes

* Random automated testing is only implemented for ALU instructions. Memory instructions are tested manually.
* There is a bug with VisUAL that will occaisonally throw an excpetion and report a mismatch between my implementation and the VisUAL output


## Owner: Youssef Rizk